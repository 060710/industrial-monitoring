<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å·¥ä¸šè®¾å¤‡æ™ºèƒ½è¿ç»´ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --primary-color: #1677ff;
            --success-color: #52c41a;
            --warning-color: #faad14;
            --error-color: #ff4d4f;
            --bg-color: #f5f5f5;
            --card-bg: #ffffff;
        }

        body {
            font-family: "Microsoft Yahei", sans-serif;
            background: var(--bg-color);
            margin: 0;
            color: rgba(0, 0, 0, 0.85);
        }

        .header {
            background: var(--primary-color);
            padding: 0 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            height: 64px;
            display: flex;
            align-items: center;
        }

        .logo {
            color: white;
            font-size: 24px;
            font-weight: bold;
            margin-right: 40px;
        }

        .search-box {
            flex: 1;
            max-width: 600px;
            margin: 0 40px;
        }

        .search-input {
            width: 100%;
            padding: 8px 16px;
            border-radius: 4px;
            border: 1px solid #d9d9d9;
            transition: all 0.3s;
        }

        .dashboard {
            max-width: 1400px;
            margin: 24px auto;
            padding: 0 24px;
        }

        .device-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 24px;
        }

        .device-card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            cursor: pointer;
            position: relative;
        }

        .device-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .success { background-color: var(--success-color); }
        .warning { background-color: var(--warning-color); }
        .error { background-color: var(--error-color); }

        .device-model {
            width: 100%;
            height: 200px;
            margin: 12px 0;
            background: #f8f9fa;
            border-radius: 4px;
            overflow: hidden;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background-color: #1677ff;
            color: white;
        }

        .status-change {
            animation: pulse 1.5s ease-in-out;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .sensor-value {
            display: flex;
            justify-content: space-between;
        }

        .sensor-meter {
            height: 6px;
            background: #f0f0f0;
            border-radius: 3px;
            margin-top: 4px;
            overflow: hidden;
        }

        .sensor-meter-fill {
            height: 100%;
            transition: width 0.5s;
        }

        .temp-fill { background: linear-gradient(to right, #52c41a, #faad14, #ff4d4f); }
        .vib-fill { background: linear-gradient(to right, #52c41a, #faad14); }
        .press-fill { background: linear-gradient(to right, #52c41a, #1677ff); }

        .last-updated {
            font-size: 12px;
            color: #999;
            text-align: right;
            margin-top: 8px;
        }

        .critical-alert {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--error-color);
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 24px;
            gap: 8px;
        }
        
        .page-btn {
            padding: 6px 12px;
            border: 1px solid #d9d9d9;
            border-radius: 4px;
            background: white;
            cursor: pointer;
        }
        
        .page-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
    </style>
</head>
<body>
    <div id="app">
        <header class="header">
            <div class="nav-container">
                <div class="action-buttons">     
                    <button class="btn btn-primary">è¿”å›æ–°æ‰‹ç•Œé¢</button>
                </div>
                <div class="logo">æ™ºèƒ½è¿ç»´å¹³å°</div>
                <div class="search-box">
                    <input type="text" 
                           class="search-input"
                           placeholder="æœç´¢è®¾å¤‡IDæˆ–ä½ç½®"
                           v-model="searchKeyword">
                </div>
            </div>
        </header>

        <main class="dashboard">
            <div class="device-grid">
                <div class="device-card" 
                     v-for="device in paginatedDevices" 
                     :key="device.id"
                     @click="showDetail(device)"
                     :class="{ 'status-change': device.animate }">
                    <div v-if="device.status === 'æ•…éšœ'" class="critical-alert">!</div>
                    <div class="card-header">
                        <h3>{{ device.device_id }}</h3>
                        <span class="status-indicator" 
                              :class="device.status === 'æ­£å¸¸' ? 'success' : 
                                     device.status === 'è­¦å‘Š' ? 'warning' : 'error'">
                        </span>
                        <span>{{ device.status }}</span>
                    </div>
                    <div class="device-model" :ref="'modelContainer'+device.id"></div>
                    <div class="card-body">
                        <p>ğŸ“ ä½ç½®ï¼š{{ device.location }}</p>
                        <p>âš™ï¸ ç±»å‹ï¼š{{ device.device_type }}</p>
                        
                        <div class="sensor-value">
                            <span>ğŸŒ¡ï¸ æ¸©åº¦ï¼š{{ device.sensor_data.temperature }}â„ƒ</span>
                            <span>{{ getTempLevel(device.sensor_data.temperature) }}</span>
                        </div>
                        <div class="sensor-meter">
                            <div class="sensor-meter-fill temp-fill" 
                                 :style="{ width: getTempPercentage(device.sensor_data.temperature) + '%' }"></div>
                        </div>
                        
                        <div class="sensor-value">
                            <span>ğŸ“³ æŒ¯åŠ¨ï¼š{{ device.sensor_data.vibration }}mm/s</span>
                            <span>{{ getVibLevel(device.sensor_data.vibration) }}</span>
                        </div>
                        <div class="sensor-meter">
                            <div class="sensor-meter-fill vib-fill" 
                                 :style="{ width: Math.min(100, device.sensor_data.vibration * 10) + '%' }"></div>
                        </div>
                        
                        <div class="sensor-value">
                            <span>ğŸ”¼ å‹åŠ›ï¼š{{ device.sensor_data.pressure }}MPa</span>
                            <span>{{ getPressLevel(device.sensor_data.pressure) }}</span>
                        </div>
                        <div class="sensor-meter">
                            <div class="sensor-meter-fill press-fill" 
                                 :style="{ width: Math.min(100, (device.sensor_data.pressure - 1) * 20) + '%' }"></div>
                        </div>
                        
                        <div v-if="device.status !== 'æ­£å¸¸'">
                            <p>âš ï¸ æ•…éšœï¼š{{ device.fault_info.type }}</p>
                            <p>ğŸ“ æè¿°ï¼š{{ device.fault_info.description }}</p>
                        </div>
                        
                        <div class="last-updated">
                            æœ€åæ›´æ–°ï¼š{{ formatTime(device.last_updated) }}
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="pagination" v-if="filteredDevices.length > itemsPerPage">
                <button class="page-btn" 
                        v-for="page in totalPages" 
                        :key="page"
                        :class="{ active: currentPage === page }"
                        @click="currentPage = page">
                    {{ page }}
                </button>
            </div>
        </main>
    </div>

    <script>
        new Vue({
            el: '#app',
            data: {
                devices: [],
                searchKeyword: '',
                dataUpdateInterval: null,
                currentPage: 1,
                itemsPerPage: 12,
                deviceTypes: [
                    'ç¦»å¿ƒæ³µ', 'å‹ç¼©æœº', 'å‘ç”µæœº', 'å†·å´å¡”', 'ä¼ é€å¸¦',
                    'ååº”é‡œ', 'åˆ†ç¦»å™¨', 'æ¢çƒ­å™¨', 'å‚¨ç½', 'æ…æ‹Œå™¨',
                    'é£æœº', 'ç©ºå‹æœº', 'å¹²ç‡¥æœº', 'è¿‡æ»¤å™¨', 'ç²‰ç¢æœº',
                    'ç¦»å¿ƒæœº', 'æŒ¤å‡ºæœº', 'æ³¨å¡‘æœº', 'æ··åˆæœº', 'åŒ…è£…æœº',
                    'è¾“é€æœº', 'æå‡æœº', 'å‹æ»¤æœº', 'è’¸é¦å¡”', 'è’¸å‘å™¨',
                    'å†·å‡å™¨', 'å¸æ”¶å¡”', 'èƒå–å¡”', 'ååº”å™¨', 'å¹²ç‡¥å¡”'
                ],
                locations: [
                    'Aè½¦é—´', 'Bè½¦é—´', 'Cä»“åº“', 'DåŒºåŸŸ', 'Eç”Ÿäº§çº¿',
                    'Fè½¦é—´', 'GåŒºåŸŸ', 'Hç”Ÿäº§çº¿', 'Iä»“åº“', 'Jå®éªŒå®¤',
                    'Kè½¦é—´', 'LåŒºåŸŸ', 'Mç”Ÿäº§çº¿', 'Nä»“åº“', 'Oå®éªŒå®¤',
                    'Pè½¦é—´', 'QåŒºåŸŸ', 'Rç”Ÿäº§çº¿', 'Sä»“åº“', 'Tå®éªŒå®¤'
                ]
            },
            computed: {
                filteredDevices() {
                    const keyword = this.searchKeyword.toLowerCase()
                    const filtered = this.devices.filter(device => 
                        device.device_id.toLowerCase().includes(keyword) ||
                        device.location.toLowerCase().includes(keyword) ||
                        device.device_type.toLowerCase().includes(keyword)
                    )
                    
                    // é‡ç½®é¡µç å½“è¿‡æ»¤ç»“æœå˜åŒ–æ—¶
                    if (filtered.length <= this.itemsPerPage) {
                        this.currentPage = 1
                    }
                    
                    return filtered
                },
                totalPages() {
                    return Math.ceil(this.filteredDevices.length / this.itemsPerPage)
                },
                paginatedDevices() {
                    const start = (this.currentPage - 1) * this.itemsPerPage
                    const end = start + this.itemsPerPage
                    return this.filteredDevices.slice(start, end)
                }
            },
            mounted() {
                // åˆå§‹åŠ è½½æ¨¡æ‹Ÿæ•°æ®
                this.devices = this.generateMockDevices()
                this.init3DModels()
                window.addEventListener('resize', this.handleResize)
                
                // è®¾ç½®å®šæ—¶æ›´æ–°æ•°æ®çš„é€»è¾‘
                this.dataUpdateInterval = setInterval(() => {
                    this.updateDeviceData()
                }, 3000) // æ¯3ç§’æ›´æ–°ä¸€æ¬¡æ•°æ®
            },
            beforeDestroy() {
                window.removeEventListener('resize', this.handleResize)
                this.cleanUp3D()
                clearInterval(this.dataUpdateInterval)
            },
            methods: {
                // ç”Ÿæˆæ¨¡æ‹Ÿè®¾å¤‡æ•°æ®
                generateMockDevices() {
                    const statuses = ['æ­£å¸¸', 'è­¦å‘Š', 'æ•…éšœ']
                    const faultTypes = [
                        'è¿‡çƒ­', 'æŒ¯åŠ¨è¿‡å¤§', 'è½´æ‰¿ç£¨æŸ', 'æ¶¦æ»‘ä¸è¶³', 'ç”µæ°”æ•…éšœ',
                        'å¯†å°æ³„æ¼', 'ç”µæœºæ•…éšœ', 'æ§åˆ¶ç³»ç»Ÿå¼‚å¸¸', 'ç®¡é“å µå¡', 'å†·å´ä¸è¶³',
                        'è½´åç§»', 'è”è½´å™¨æŸå', 'é½¿è½®ç£¨æŸ', 'çš®å¸¦æ¾å¼›', 'ç”µå‹ä¸ç¨³'
                    ]
                    const descriptions = [
                        'éœ€è¦æ£€æŸ¥', 'å»ºè®®ç»´æŠ¤', 'ç«‹å³æ£€ä¿®', 'åœæœºç»´ä¿®', 'ç´§æ€¥å¤„ç†',
                        'ä¼ æ„Ÿå™¨å¼‚å¸¸', 'å‚æ•°è¶…æ ‡', 'æ•ˆç‡ä¸‹é™', 'å™ªéŸ³å¼‚å¸¸', 'æŒ¯åŠ¨è¶…æ ‡',
                        'æ¸©åº¦è¿‡é«˜', 'å‹åŠ›å¼‚å¸¸', 'æµé‡ä¸è¶³', 'ç”µæµæ³¢åŠ¨', 'ç»ç¼˜è€åŒ–'
                    ]
                    
                    return Array.from({length: 30}, (_, i) => {
                        const status = statuses[Math.floor(Math.random() * statuses.length)]
                        const isFault = status === 'æ•…éšœ'
                        
                        return {
                            id: `DEV-${1000 + i}`,
                            device_id: `è®¾å¤‡-${1000 + i}`,
                            device_type: this.deviceTypes[Math.floor(Math.random() * this.deviceTypes.length)],
                            location: this.locations[Math.floor(Math.random() * this.locations.length)],
                            status: status,
                            sensor_data: {
                                temperature: Math.round(20 + Math.random() * 30 * 10) / 10,
                                vibration: Math.round(Math.random() * 10 * 10) / 10,
                                pressure: Math.round(1 + Math.random() * 5 * 10) / 10,
                                current: Math.round(5 + Math.random() * 15 * 10) / 10,
                                flow: Math.round(10 + Math.random() * 90 * 10) / 10
                            },
                            fault_info: {
                                type: isFault ? faultTypes[Math.floor(Math.random() * faultTypes.length)] : null,
                                description: isFault ? descriptions[Math.floor(Math.random() * descriptions.length)] : 'æ— '
                            },
                            last_updated: new Date(),
                            animate: false
                        }
                    })
                },
                
                // æ›´æ–°è®¾å¤‡æ•°æ®
                updateDeviceData() {
                    this.devices = this.devices.map(device => {
                        // éšæœºå†³å®šæ˜¯å¦æ”¹å˜çŠ¶æ€ (20%æ¦‚ç‡)
                        const shouldChangeStatus = Math.random() < 0.2
                        
                        // æ›´æ–°ä¼ æ„Ÿå™¨æ•°æ®
                        const tempChange = (Math.random() * 2 - 1) * (device.status === 'æ•…éšœ' ? 1.5 : 1)
                        const vibChange = (Math.random() * 0.5 - 0.25) * (device.status === 'æ•…éšœ' ? 2 : 1)
                        const pressChange = (Math.random() * 0.3 - 0.15) * (device.status === 'æ•…éšœ' ? 1.5 : 1)
                        
                        const newTemp = device.sensor_data.temperature + tempChange
                        const newVibration = device.sensor_data.vibration + vibChange
                        const newPressure = device.sensor_data.pressure + pressChange
                        
                        // ç¡®ä¿æ•°å€¼åœ¨åˆç†èŒƒå›´å†…
                        const clampedTemp = Math.max(20, Math.min(60, newTemp))
                        const clampedVibration = Math.max(0, Math.min(15, newVibration))
                        const clampedPressure = Math.max(0.5, Math.min(7, newPressure))
                        
                        // åˆ›å»ºæ›´æ–°åçš„è®¾å¤‡å¯¹è±¡
                        const updatedDevice = {
                            ...device,
                            sensor_data: {
                                ...device.sensor_data,
                                temperature: Math.round(clampedTemp * 10) / 10,
                                vibration: Math.round(clampedVibration * 10) / 10,
                                pressure: Math.round(clampedPressure * 10) / 10,
                                current: Math.round((5 + Math.random() * 15) * 10) / 10,
                                flow: Math.round((10 + Math.random() * 90) * 10) / 10
                            },
                            last_updated: new Date(),
                            animate: false
                        }
                        
                        // éšæœºæ”¹å˜çŠ¶æ€
                        if (shouldChangeStatus) {
                            const statuses = ['æ­£å¸¸', 'è­¦å‘Š', 'æ•…éšœ']
                            const faultTypes = [
                                'è¿‡çƒ­', 'æŒ¯åŠ¨è¿‡å¤§', 'è½´æ‰¿ç£¨æŸ', 'æ¶¦æ»‘ä¸è¶³', 'ç”µæ°”æ•…éšœ',
                                'å¯†å°æ³„æ¼', 'ç”µæœºæ•…éšœ', 'æ§åˆ¶ç³»ç»Ÿå¼‚å¸¸', 'ç®¡é“å µå¡', 'å†·å´ä¸è¶³',
                                'è½´åç§»', 'è”è½´å™¨æŸå', 'é½¿è½®ç£¨æŸ', 'çš®å¸¦æ¾å¼›', 'ç”µå‹ä¸ç¨³'
                            ]
                            const descriptions = [
                                'éœ€è¦æ£€æŸ¥', 'å»ºè®®ç»´æŠ¤', 'ç«‹å³æ£€ä¿®', 'åœæœºç»´ä¿®', 'ç´§æ€¥å¤„ç†',
                                'ä¼ æ„Ÿå™¨å¼‚å¸¸', 'å‚æ•°è¶…æ ‡', 'æ•ˆç‡ä¸‹é™', 'å™ªéŸ³å¼‚å¸¸', 'æŒ¯åŠ¨è¶…æ ‡',
                                'æ¸©åº¦è¿‡é«˜', 'å‹åŠ›å¼‚å¸¸', 'æµé‡ä¸è¶³', 'ç”µæµæ³¢åŠ¨', 'ç»ç¼˜è€åŒ–'
                            ]
                            
                            updatedDevice.status = statuses[Math.floor(Math.random() * statuses.length)]
                            
                            if (updatedDevice.status === 'æ•…éšœ') {
                                updatedDevice.fault_info = {
                                    type: faultTypes[Math.floor(Math.random() * faultTypes.length)],
                                    description: descriptions[Math.floor(Math.random() * descriptions.length)]
                                }
                                // æ•…éšœè®¾å¤‡æ¸©åº¦æ›´é«˜
                                updatedDevice.sensor_data.temperature = Math.round(
                                    Math.min(60, updatedDevice.sensor_data.temperature + 5 + Math.random() * 5) * 10
                                ) / 10
                                // æ•…éšœè®¾å¤‡æŒ¯åŠ¨æ›´å¤§
                                updatedDevice.sensor_data.vibration = Math.round(
                                    Math.min(15, updatedDevice.sensor_data.vibration + 3 + Math.random() * 3) * 10
                                ) / 10
                            } else {
                                updatedDevice.fault_info = {
                                    type: null,
                                    description: 'æ— '
                                }
                            }
                            
                            // æ ‡è®°éœ€è¦åŠ¨ç”»
                            updatedDevice.animate = true
                            
                            // æ›´æ–°3Dæ¨¡å‹é¢œè‰²
                            this.updateModelColor(device.id, updatedDevice.status)
                        }
                        
                        // æ¸©åº¦å˜åŒ–å¤§æ—¶ä¹Ÿè§¦å‘åŠ¨ç”»
                        if (Math.abs(updatedDevice.sensor_data.temperature - device.sensor_data.temperature) > 3 ||
                            Math.abs(updatedDevice.sensor_data.vibration - device.sensor_data.vibration) > 1.5 ||
                            Math.abs(updatedDevice.sensor_data.pressure - device.sensor_data.pressure) > 0.5) {
                            updatedDevice.animate = true
                        }
                        
                        return updatedDevice
                    })
                    
                    // æ¸…é™¤åŠ¨ç”»æ ‡è®°
                    setTimeout(() => {
                        this.devices.forEach(device => {
                            if (device.animate) {
                                device.animate = false
                            }
                        })
                    }, 1500)
                },
                
                // è·å–æ¸©åº¦ç­‰çº§
                getTempLevel(temp) {
                    if (temp < 30) return 'æ­£å¸¸'
                    if (temp < 45) return 'æ³¨æ„'
                    return 'å±é™©'
                },
                
                // è·å–æŒ¯åŠ¨ç­‰çº§
                getVibLevel(vib) {
                    if (vib < 3) return 'æ­£å¸¸'
                    if (vib < 6) return 'æ³¨æ„'
                    return 'å±é™©'
                },
                
                // è·å–å‹åŠ›ç­‰çº§
                getPressLevel(press) {
                    if (press < 2) return 'ä½'
                    if (press < 5) return 'æ­£å¸¸'
                    return 'é«˜'
                },
                
                // è®¡ç®—æ¸©åº¦ç™¾åˆ†æ¯”
                getTempPercentage(temp) {
                    return Math.min(100, (temp - 20) / 0.4)
                },
                
                // æ ¼å¼åŒ–æ—¶é—´
                formatTime(date) {
                    return date.toLocaleTimeString()
                },
                
                init3DModels() {
                    this.$nextTick(() => {
                        this.devices.forEach(device => {
                            const container = this.$refs[`modelContainer${device.id}`]?.[0]
                            if (container) {
                                device.threeJS = this.initThreeJS(container, device)
                            }
                        })
                    })
                },

                initThreeJS(container, device) {
                    // åœºæ™¯åˆå§‹åŒ–
                    const scene = new THREE.Scene()
                    const camera = new THREE.PerspectiveCamera(
                        75,
                        container.clientWidth / container.clientHeight,
                        0.1,
                        1000
                    )
                    
                    // æ¸²æŸ“å™¨é…ç½®
                    const renderer = new THREE.WebGLRenderer({ 
                        antialias: true,
                        alpha: true
                    })
                    renderer.setSize(container.clientWidth, container.clientHeight)
                    container.innerHTML = ''
                    container.appendChild(renderer.domElement)

                    // ç¯å…‰è®¾ç½®
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
                    scene.add(ambientLight)
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
                    directionalLight.position.set(5, 5, 5)
                    scene.add(directionalLight)

                    // æ ¹æ®è®¾å¤‡ç±»å‹åˆ›å»ºä¸åŒå‡ ä½•ä½“
                    let geometry, material
                    switch(device.device_type) {
                        case 'ç¦»å¿ƒæ³µ':
                            geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32)
                            break
                        case 'å‹ç¼©æœº':
                            geometry = new THREE.BoxGeometry(1, 0.6, 0.8)
                            break
                        case 'å‘ç”µæœº':
                            geometry = new THREE.SphereGeometry(0.6, 32, 32)
                            break
                        case 'å†·å´å¡”':
                            geometry = new THREE.ConeGeometry(0.6, 1, 32)
                            break
                        case 'ä¼ é€å¸¦':
                            geometry = new THREE.BoxGeometry(1.2, 0.3, 0.4)
                            break
                        case 'ååº”é‡œ':
                            geometry = new THREE.SphereGeometry(0.7, 32, 32)
                            break
                        case 'åˆ†ç¦»å™¨':
                            geometry = new THREE.CylinderGeometry(0.6, 0.3, 1, 32)
                            break
                        case 'å‚¨ç½':
                            geometry = new THREE.CylinderGeometry(0.7, 0.7, 0.5, 32)
                            break
                        case 'æ…æ‹Œå™¨':
                            geometry = new THREE.TorusGeometry(0.4, 0.1, 16, 32)
                            break
                        case 'é£æœº':
                            geometry = new THREE.ConeGeometry(0.5, 0.8, 32)
                            break
                        case 'ç©ºå‹æœº':
                            geometry = new THREE.BoxGeometry(0.9, 0.7, 0.6)
                            break
                        case 'å¹²ç‡¥æœº':
                            geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 32)
                            break
                        case 'è¿‡æ»¤å™¨':
                            geometry = new THREE.TorusKnotGeometry(0.4, 0.1, 100, 16)
                            break
                        case 'ç²‰ç¢æœº':
                            geometry = new THREE.OctahedronGeometry(0.6)
                            break
                        case 'ç¦»å¿ƒæœº':
                            geometry = new THREE.CylinderGeometry(0.4, 0.6, 0.7, 32)
                            break
                        case 'æŒ¤å‡ºæœº':
                            geometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 32)
                            break
                        case 'æ³¨å¡‘æœº':
                            geometry = new THREE.BoxGeometry(1, 0.8, 0.6)
                            break
                        case 'æ··åˆæœº':
                            geometry = new THREE.DodecahedronGeometry(0.6)
                            break
                        case 'åŒ…è£…æœº':
                            geometry = new THREE.BoxGeometry(1.1, 0.5, 0.5)
                            break
                        case 'è¾“é€æœº':
                            geometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 32)
                            break
                        case 'æå‡æœº':
                            geometry = new THREE.BoxGeometry(0.5, 1, 0.5)
                            break
                        case 'å‹æ»¤æœº':
                            geometry = new THREE.BoxGeometry(0.8, 0.4, 0.8)
                            break
                        case 'è’¸é¦å¡”':
                            geometry = new THREE.CylinderGeometry(0.3, 0.5, 1.5, 32)
                            break
                        case 'è’¸å‘å™¨':
                            geometry = new THREE.SphereGeometry(0.6, 32, 32)
                            break
                        case 'å†·å‡å™¨':
                            geometry = new THREE.BoxGeometry(0.7, 0.7, 0.7)
                            break
                        case 'å¸æ”¶å¡”':
                            geometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 32)
                            break
                        case 'èƒå–å¡”':
                            geometry = new THREE.CylinderGeometry(0.5, 0.3, 1.3, 32)
                            break
                        case 'ååº”å™¨':
                            geometry = new THREE.SphereGeometry(0.8, 32, 32)
                            break
                        case 'å¹²ç‡¥å¡”':
                            geometry = new THREE.CylinderGeometry(0.5, 0.2, 1.4, 32)
                            break
                        default:
                            geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8)
                    }

                    material = new THREE.MeshPhongMaterial({ 
                        color: device.status === 'æ­£å¸¸' ? 0x00ff00 : 
                               device.status === 'è­¦å‘Š' ? 0xffff00 : 0xff0000,
                        transparent: true,
                        opacity: 0.8,
                        shininess: 100
                    })
                    
                    const mesh = new THREE.Mesh(geometry, material)
                    scene.add(mesh)
                    camera.position.z = 2.5

                    // æ§åˆ¶å™¨é…ç½®
                    const controls = new THREE.OrbitControls(camera, renderer.domElement)
                    controls.enableDamping = true
                    controls.dampingFactor = 0.05
                    controls.maxDistance = 5
                    controls.minDistance = 1

                    // åŠ¨ç”»å¾ªç¯
                    function animate() {
                        requestAnimationFrame(animate)
                        mesh.rotation.x += 0.005
                        mesh.rotation.y += 0.01
                        controls.update()
                        renderer.render(scene, camera)
                    }
                    animate()

                    return { scene, camera, renderer, controls, mesh }
                },

                // æ›´æ–°3Dæ¨¡å‹é¢œè‰²
                updateModelColor(deviceId, status) {
                    const container = this.$refs[`modelContainer${deviceId}`]?.[0]
                    if (!container || !container.threeJS) return
                    
                    const { mesh } = container.threeJS
                    mesh.material.color.setHex(
                        status === 'æ­£å¸¸' ? 0x00ff00 : 
                        status === 'è­¦å‘Š' ? 0xffff00 : 0xff0000
                    )
                },

                handleResize() {
                    this.devices.forEach(device => {
                        if (device.threeJS) {
                            const container = this.$refs[`modelContainer${device.id}`]?.[0]
                            if (!container) return
                            
                            const { camera, renderer } = device.threeJS
                            camera.aspect = container.clientWidth / container.clientHeight
                            camera.updateProjectionMatrix()
                            renderer.setSize(container.clientWidth, container.clientHeight)
                        }
                    })
                },

                cleanUp3D() {
                    this.devices.forEach(device => {
                        if (device.threeJS) {
                            const { renderer, controls } = device.threeJS
                            renderer.domElement.remove()
                            controls.dispose()
                            device.threeJS = null
                        }
                    })
                },

                showDetail(device) {
                    alert(`è®¾å¤‡è¯¦æƒ…:\n\n` +
                          `è®¾å¤‡ID: ${device.device_id}\n` +
                          `ç±»å‹: ${device.device_type}\n` +
                          `ä½ç½®: ${device.location}\n` +
                          `çŠ¶æ€: ${device.status}\n\n` +
                          `ä¼ æ„Ÿå™¨æ•°æ®:\n` +
                          `æ¸©åº¦: ${device.sensor_data.temperature}â„ƒ\n` +
                          `æŒ¯åŠ¨: ${device.sensor_data.vibration}mm/s\n` +
                          `å‹åŠ›: ${device.sensor_data.pressure}MPa\n` +
                          `ç”µæµ: ${device.sensor_data.current}A\n` +
                          `æµé‡: ${device.sensor_data.flow}L/min\n\n` +
                          `æœ€åæ›´æ–°: ${this.formatTime(device.last_updated)}`)
                }
            }
        })
    </script>
</body>
</html>
